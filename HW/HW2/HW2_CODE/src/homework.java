import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.net.URL;
import java.util.Scanner;

//Have to implement the depth
//Have to implement Min Max
//Have to implement

class Value{
	int value;
	int xReturned;
	int yReturned;
	boolean stack = true;
	char[][] boardState;
}

class Node{
	//int MinValue = 2147483647; // while going to the root
	//ArrayList<Node> nodeList = new ArrayList<>();// list of all the successor nodes
	int x = -1;
	int y = -1;
	char[][] boardState;
	boolean stack = true;

}


public class homework {

	static int MAX_VALUE = -2147483648;
	static int MIN_VALUE = 2147483647;
	static char sMyPlayer;
	static char sOtherPlayer;
	static int[][] valueMatrix;
	static int matrixSize;
	static PrintWriter writer=null;
	static int sDepth = 0;
	static int sMaxDepthPossible =0;
	//lets start by taking the input.
	public static void main(String args[]){

		Scanner scanner = null;

		URL url = homework.class.getResource("input.txt");

		File file = new File(url.getPath());

		try{
			scanner = new Scanner(new FileReader(file));
		}catch(Exception e){
			e.printStackTrace();
		}

		if(scanner == null){
			//terminate as scanner is null
			System.out.println("Scanner is null");
			return;
		}


		try {
			writer = new PrintWriter("output.txt", "UTF-8");
		} catch (FileNotFoundException | UnsupportedEncodingException e1) {
			e1.printStackTrace();
		}

		matrixSize = scanner.nextInt(); //N*N matrix

		//It gives the game playing mode as “MINIMAX” or “ALPHABETA” or “COMPETITION”
		String mode = scanner.next();

		//My Play either I am player X or player O


		String myPlayer= scanner.next();
		sMyPlayer = myPlayer.charAt(0);

		if(sMyPlayer == 'X'){
			sOtherPlayer = 'O';
		}else{
			sOtherPlayer = 'X';
		}

		//Max depth I can go
		sDepth = scanner.nextInt();

		//Lets initialize 2 N*N matrix
		//One to write the values of each cell and the other to write the Board state
		valueMatrix = new int[matrixSize][matrixSize];

		//Lets modify the board state
		char[][] boardState = new char[matrixSize][matrixSize];

		for(int i=0; i<matrixSize; i++){
			for(int j=0; j<matrixSize; j++){
				valueMatrix[i][j] = scanner.nextInt();
			}
		}


		Node mInitialNode = new Node(); 

		for(int i=0; i<matrixSize; i++){
			String s = scanner.next();
			for(int j=0; j<matrixSize; j++){
				boardState[i][j] = s.charAt(j);
				if(boardState[i][j]=='.'){
					sMaxDepthPossible++;
				}
			}
		}

		if(sDepth>sMaxDepthPossible){
			System.out.println("This depth is not reachable");
			System.out.println("Maximum possible depth =" + sMaxDepthPossible);
			sDepth = sMaxDepthPossible;
		}

		mInitialNode.boardState =  boardState;

		Value mValue = null;

		if(mode.equals("MINIMAX")){
			System.out.println("Tree generation started");
			long startTime = System.currentTimeMillis();
			mValue = generateMaxValues(mInitialNode,0);
			System.out.println("Tree generation completed");
			//Value = X+1;
			//Y convert to alphabet
			outputResult(myPlayer, mValue);
			long endTime   = System.currentTimeMillis();
			long totalTime = endTime - startTime;
			System.out.println(totalTime);		

			//print all the values generated by initial state, let me check by printing the path
		}else if(mode.equals("ALPHABETA")){
			long startTime = System.currentTimeMillis();
			mValue = generateMaxValuesAB(mInitialNode,0,MAX_VALUE,MIN_VALUE);
			outputResult(myPlayer, mValue);
			long endTime   = System.currentTimeMillis();
			long totalTime = endTime - startTime;
			System.out.println(totalTime);			
		}else{
			//Nop Sorry!!! Haven't done first midterm well, might participate if I finish solving all the first test portions again.
		}

		try{
			writer.close();
		}catch (Exception e) {
			e.printStackTrace();
		}


	}

	private static Value generateMaxValuesAB(Node pCurrentNode, int mDepth, int mAlpha, int mBeta) {


		Value theMaxValue = new Value();
		theMaxValue.value= MAX_VALUE;

		//Have to terminate even if it is the leaf node
		//Have to still implement it
		if(mDepth == sDepth){
			Value mValue = new Value();
			mValue.xReturned = pCurrentNode.x;
			mValue.yReturned = pCurrentNode.y;
			mValue.value = computeScore(pCurrentNode.boardState);
			return mValue;
		}

		int move =1; //for stake

		while(move<3){
			for(int i=0;i<matrixSize; i++){
				for(int j=0; j<matrixSize; j++){
					if(pCurrentNode.boardState[i][j] == '.'){
						//put your player in this position and do all the stack or raid operation and call the min function with the new board
						Node mNode = new Node();
						mNode.x = i; //Row
						mNode.y = j; //Column
						mNode.boardState = new char[matrixSize][matrixSize];
						for(int l=0; l<matrixSize; l++){   //Copied the board
							for(int m=0; m<matrixSize; m++){
								mNode.boardState[l][m] = pCurrentNode.boardState[l][m];
							}
						}

						int x = mNode.x;
						int y = mNode.y;
						

						mNode.boardState[x][y] = sMyPlayer;
						//mNode.MaxValue = valueMatrix[x][y];


						int temp = theMaxValue.value;
						//check Left
						//if !your play matches with this then maxValue should be decreased and minValue should be increased by same value and board value should be changed

						if(move==1){
							temp = theMaxValue.value;
							theMaxValue = max(theMaxValue , generateMinValuesAB(mNode, mDepth+1, mAlpha, mBeta));

							if(temp < theMaxValue.value){
								theMaxValue.xReturned = i;
								theMaxValue.yReturned = j;
								theMaxValue.stack = mNode.stack;
								theMaxValue.boardState = mNode.boardState;
							}

							if(theMaxValue.value >= mBeta){
								return theMaxValue;
							}

							mAlpha = maxInt(mAlpha,theMaxValue.value);

						}
						if(move==2){

							boolean canRaid = false;
							int xLeft = mNode.x-1;
							int xRight = mNode.x+1;
							int yTop= mNode.y-1;
							int yBottom = mNode.y+1;

							if(xLeft >= 0 && mNode.boardState[xLeft][y] == sMyPlayer){
								canRaid = true;
							}
							//check Right
							if(xRight < matrixSize && mNode.boardState[xRight][y] == sMyPlayer){
								canRaid = true;
							}
							//check Top
							if(yTop>=0 && mNode.boardState[x][yTop] == sMyPlayer){
								canRaid = true;
							}
							//check bottom
							if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sMyPlayer){
								canRaid = true;
							}

							if(canRaid){
								if(xLeft >= 0 && mNode.boardState[xLeft][y] == sOtherPlayer){
									mNode.boardState[xLeft][y] = sMyPlayer;
									mNode.stack = false;
								}
								//check Right
								if(xRight < matrixSize && mNode.boardState[xRight][y] == sOtherPlayer){
									mNode.boardState[xRight][y] = sMyPlayer;
									mNode.stack = false;
								}
								//check Top
								if(yTop>=0 && mNode.boardState[x][yTop] == sOtherPlayer){
									mNode.boardState[x][yTop] = sMyPlayer;
									mNode.stack = false;
								}
								//check bottom
								if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sOtherPlayer){
									mNode.boardState[x][yBottom] = sMyPlayer;
									mNode.stack = false;
								}

								temp = theMaxValue.value;

								theMaxValue = max(theMaxValue , generateMinValuesAB(mNode, mDepth+1, mAlpha, mBeta));

								if(temp < theMaxValue.value){
									theMaxValue.xReturned = i;
									theMaxValue.yReturned = j;
									theMaxValue.stack = mNode.stack;
									theMaxValue.boardState = mNode.boardState;
								}

								if(theMaxValue.value >= mBeta){
									return theMaxValue;
								}

								mAlpha = maxInt(mAlpha,theMaxValue.value);
							}
						}
					}
				}
			}
			move++;
		}
		return theMaxValue;

	}

	private static Value generateMinValuesAB(Node pCurrentNode, int mDepth, int mAlpha, int mBeta) {

		Value theMinValue = new Value();
		theMinValue.value= MIN_VALUE;

		//Have to terminate even if it is the leaf node
		//Have to still implement it
		if(mDepth == sDepth){
			Value mValue = new Value();
			mValue.xReturned = pCurrentNode.x;
			mValue.yReturned = pCurrentNode.y;
			mValue.value = computeScore(pCurrentNode.boardState);
			return mValue;
		}

		int move =1; //for stake

		while(move<3){
			for(int i=0;i<matrixSize; i++){
				for(int j=0; j<matrixSize; j++){
					if(pCurrentNode.boardState[i][j] == '.'){
						//put your player in this position and do all the stack or raid operation and call the min function with the new board
						Node mNode = new Node();
						mNode.x = i; //Row
						mNode.y = j; //Column
						mNode.boardState = new char[matrixSize][matrixSize];
						for(int l=0; l<matrixSize; l++){   //Copied the board
							for(int m=0; m<matrixSize; m++){
								mNode.boardState[l][m] = pCurrentNode.boardState[l][m];
							}
						}

						int x = mNode.x;
						int y = mNode.y;

						mNode.boardState[x][y] = sOtherPlayer;
						//mNode.MinValue = valueMatrix[x][y];


						//check Left
						//if !your play matches with this then maxValue should be decreased and minValue should be increased by same value and board value should be changed
						if(move==1){
							theMinValue = min(theMinValue , generateMaxValuesAB(mNode, mDepth+1, mAlpha, mBeta));
							if(theMinValue.value <= mAlpha){
								return theMinValue;
							}
							mBeta = minInt(mBeta,theMinValue.value);
						}
						if(move ==2){
							boolean canRaid = false;
							int xLeft = mNode.x-1;
							int xRight = mNode.x+1;
							int yTop= mNode.y-1;
							int yBottom = mNode.y+1;

							if(xLeft >= 0 && mNode.boardState[xLeft][y] == sOtherPlayer){
								canRaid = true;
							}
							//check Right
							if(xRight < matrixSize && mNode.boardState[xRight][y] == sOtherPlayer){
								canRaid = true;
							}
							//check Top
							if(yTop>=0 && mNode.boardState[x][yTop] == sOtherPlayer){
								canRaid = true;
							}
							//check bottom
							if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sOtherPlayer){
								canRaid = true;
							}

							if(canRaid){
								if(xLeft >= 0 && mNode.boardState[xLeft][y] == sMyPlayer){
									mNode.boardState[xLeft][y] = sOtherPlayer;
									mNode.stack = false;
								}
								//check Right
								if(xRight < matrixSize && mNode.boardState[xRight][y] == sMyPlayer){
									mNode.boardState[xRight][y] = sOtherPlayer;
									mNode.stack = false;
								}
								//check Top
								if(yTop>=0 && mNode.boardState[x][yTop] == sMyPlayer){
									mNode.boardState[x][yTop] = sOtherPlayer;
									mNode.stack = false;
								}
								//check bottom
								if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sMyPlayer){
									mNode.boardState[x][yBottom] = sOtherPlayer;
									mNode.stack = false;
								}
								theMinValue = min(theMinValue , generateMaxValuesAB(mNode, mDepth+1, mAlpha, mBeta));
								if(theMinValue.value <= mAlpha){
									return theMinValue;
								}
								mBeta = minInt(mBeta,theMinValue.value);
							}
						}
					}
				}
			}
			move++;
		}
		return theMinValue;
	}


	private static Value generateMaxValues(Node pCurrentNode, int mDepth) {

		Value theMaxValue = new Value();
		theMaxValue.value= MAX_VALUE;

		//Have to terminate even if it is the leaf node
		//Have to still implement it
		if(mDepth == sDepth){
			Value mValue = new Value();
			mValue.xReturned = pCurrentNode.x;
			mValue.yReturned = pCurrentNode.y;
			mValue.value = computeScore(pCurrentNode.boardState);
			return mValue;
		}

		int move =1; //for stake

		while(move<3){
			for(int i=0;i<matrixSize; i++){
				for(int j=0; j<matrixSize; j++){
					if(pCurrentNode.boardState[i][j] == '.'){
						//put your player in this position and do all the stack or raid operation and call the min function with the new board
						Node mNode = new Node();
						mNode.x = i; //Row
						mNode.y = j; //Column
						mNode.boardState = new char[matrixSize][matrixSize];
						for(int l=0; l<matrixSize; l++){   //Copied the board
							for(int m=0; m<matrixSize; m++){
								mNode.boardState[l][m] = pCurrentNode.boardState[l][m];
							}
						}

						int x = mNode.x;
						int y = mNode.y;

						mNode.boardState[x][y] = sMyPlayer;
						//mNode.MaxValue = valueMatrix[x][y];


						int temp = theMaxValue.value;
						//check Left
						//if !your play matches with this then maxValue should be decreased and minValue should be increased by same value and board value should be changed

						if(move==1){
							temp = theMaxValue.value;
							theMaxValue = max(theMaxValue , generateMinValues(mNode, mDepth+1));
							//	writer.println("depth=" + mDepth + " Max Value =" + theMaxValue.value + " x=" + i + " y=" +j );
							if(temp < theMaxValue.value){
								theMaxValue.xReturned = i;
								theMaxValue.yReturned = j;
								theMaxValue.stack = mNode.stack;
								theMaxValue.boardState = mNode.boardState;
								//writer.println("depth=" + mDepth + " Max Value =" + theMaxValue.value + " x=" + i + " y=" +j );
							}
						}
						else if(move==2){

							boolean canRaid = false;
							int xLeft = mNode.x-1;
							int xRight = mNode.x+1;
							int yTop= mNode.y-1;
							int yBottom = mNode.y+1;

							if(xLeft >= 0 && mNode.boardState[xLeft][y] == sMyPlayer){
								canRaid = true;
							}
							//check Right
							if(xRight < matrixSize && mNode.boardState[xRight][y] == sMyPlayer){
								canRaid = true;
							}
							//check Top
							if(yTop>=0 && mNode.boardState[x][yTop] == sMyPlayer){
								canRaid = true;
							}
							//check bottom
							if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sMyPlayer){
								canRaid = true;
							}

							if(canRaid){
								if(xLeft >= 0 && mNode.boardState[xLeft][y] == sOtherPlayer){
									mNode.boardState[xLeft][y] = sMyPlayer;
									mNode.stack = false;
								}
								//check Right
								if(xRight < matrixSize && mNode.boardState[xRight][y] == sOtherPlayer){
									mNode.boardState[xRight][y] = sMyPlayer;
									mNode.stack = false;
								}
								//check Top
								if(yTop>=0 && mNode.boardState[x][yTop] == sOtherPlayer){
									mNode.boardState[x][yTop] = sMyPlayer;
									mNode.stack = false;
								}
								//check bottom
								if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sOtherPlayer){
									mNode.boardState[x][yBottom] = sMyPlayer;
									mNode.stack = false;
								}
								temp = theMaxValue.value;
								theMaxValue = max(theMaxValue , generateMinValues(mNode, mDepth+1));
								if(temp < theMaxValue.value){
									theMaxValue.xReturned = i;
									theMaxValue.yReturned = j;
									theMaxValue.stack = mNode.stack;
									theMaxValue.boardState = mNode.boardState;
								}
							}
						}
					}
				}
			}
			move++;
		}
		return theMaxValue;
	}



	private static Value generateMinValues(Node pCurrentNode, int mDepth) {

		Value theMinValue = new Value();
		theMinValue.value= MIN_VALUE;

		//Have to terminate even if it is the leaf node
		//Have to still implement it
		if(mDepth == sDepth){
			Value mValue = new Value();
			mValue.xReturned = pCurrentNode.x;
			mValue.yReturned = pCurrentNode.y;
			mValue.value = computeScore(pCurrentNode.boardState);
			return mValue;
		}

		int move =1; //for stake

		while(move<3){
			for(int i=0;i<matrixSize; i++){
				for(int j=0; j<matrixSize; j++){
					if(pCurrentNode.boardState[i][j] == '.'){
						//put your player in this position and do all the stack or raid operation and call the min function with the new board
						Node mNode = new Node();
						mNode.x = i; //Row
						mNode.y = j; //Column
						mNode.boardState = new char[matrixSize][matrixSize];
						for(int l=0; l<matrixSize; l++){   //Copied the board
							for(int m=0; m<matrixSize; m++){
								mNode.boardState[l][m] = pCurrentNode.boardState[l][m];
							}
						}

						int x = mNode.x;
						int y = mNode.y;


						mNode.boardState[x][y] = sOtherPlayer;
						//mNode.MinValue = valueMatrix[x][y];


						//check Left
						//if !your play matches with this then maxValue should be decreased and minValue should be increased by same value and board value should be changed
						if(move==1){
							theMinValue = min(theMinValue , generateMaxValues(mNode, mDepth+1));
						}else if(move==2){

							boolean canRaid = false;

							int xLeft = mNode.x-1;
							int xRight = mNode.x+1;

							int yTop= mNode.y-1;
							int yBottom = mNode.y+1;

							if(xLeft >= 0 && mNode.boardState[xLeft][y] == sOtherPlayer){
								canRaid = true;
							}
							//check Right
							if(xRight < matrixSize && mNode.boardState[xRight][y] == sOtherPlayer){
								canRaid = true;
							}
							//check Top
							if(yTop>=0 && mNode.boardState[x][yTop] == sOtherPlayer){
								canRaid = true;
							}
							//check bottom
							if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sOtherPlayer){
								canRaid = true;
							}

							if(canRaid){
								if(xLeft >= 0 && mNode.boardState[xLeft][y] == sMyPlayer){
									mNode.boardState[xLeft][y] = sOtherPlayer;
									mNode.stack = false;
								}
								//check Right
								if(xRight < matrixSize && mNode.boardState[xRight][y] == sMyPlayer){
									mNode.boardState[xRight][y] = sOtherPlayer;
									mNode.stack = false;
								}
								//check Top
								if(yTop>=0 && mNode.boardState[x][yTop] == sMyPlayer){
									mNode.boardState[x][yTop] = sOtherPlayer;
									mNode.stack = false;
								}
								//check bottom
								if(yBottom < matrixSize && mNode.boardState[x][yBottom] == sMyPlayer){
									mNode.boardState[x][yBottom] = sOtherPlayer;
									mNode.stack = false;
								}
								theMinValue = min(theMinValue , generateMaxValues(mNode, mDepth+1));
							}
						}


					}
				}
			}
			move++;
		}
		return theMinValue;
	}


	private static void outputResult(String myPlayer, Value mValue) {
		char column = (char) (mValue.yReturned + 65);
		writer.print(column + "" + (mValue.xReturned+1));
		if(mValue.stack){
			writer.println(" Stake");
		}else{
			writer.println(" Raid");
		}

		for(int l=0; l<matrixSize; l++){
			for(int m=0; m<matrixSize; m++){
				//if(!(l == mValue.xReturned && m==mValue.yReturned)){
				writer.print(mValue.boardState[l][m]);
				//}else{
				//	writer.print(myPlayer);
				//}
			}
			writer.println();
		}
	}


	private static int minInt(int value1, int value2) {
		if(value1>value2){
			return value2;
		}
		return value1;
	}

	private static int maxInt(int value1, int value2) {
		if(value1>value2){
			return value1;
		}
		return value2;
	}

	private static Value max(Value mValue, Value mCheckValue) {
		//writer.print("mValue = " + mValue.value + "To check Value =" + mCheckValue.value + " ");
		if(mValue.value>=mCheckValue.value){
			return mValue;
		}
		return mCheckValue;
	}

	private static Value min(Value mValue, Value mCheckValue) {
		if(mValue.value<=mCheckValue.value){
			return mValue;
		}
		return mCheckValue;
	}


	private static int computeScore(char[][] boardState) {

		int value =0;

		for(int i=0; i< matrixSize; i++){
			for(int j=0; j< matrixSize; j++){
				if(boardState[i][j] !='.' && boardState[i][j] == sMyPlayer){
					value += valueMatrix[i][j];
				}else if(boardState[i][j] !='.'){
					value -= valueMatrix[i][j];
				}
			}
		}
		return value;
	}
}
